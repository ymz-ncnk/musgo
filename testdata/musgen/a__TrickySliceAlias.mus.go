// Code generated by musgen. DO NOT EDIT.

package musgen

import "github.com/ymz-ncnk/muserrs"

// Marshal fills buf with the MUS encoding of v.
func (v TrickySliceAlias) Marshal(buf []byte) int {
	i := 0
	{
		length := len(v)
		{
			uv := uint64(length)
			if length < 0 {
				uv = ^(uv << 1)
			} else {
				uv = uv << 1
			}
			{
				for uv >= 0x80 {
					buf[i] = byte(uv) | 0x80
					uv >>= 7
					i++
				}
				buf[i] = byte(uv)
				i++
			}
		}
		for _, el := range v {
			{
				for _, item := range el {
					{
						length := len(item)
						{
							uv := uint64(length)
							if length < 0 {
								uv = ^(uv << 1)
							} else {
								uv = uv << 1
							}
							{
								for uv >= 0x80 {
									buf[i] = byte(uv) | 0x80
									uv >>= 7
									i++
								}
								buf[i] = byte(uv)
								i++
							}
						}
						for ke, vl := range item {
							if ke == nil {
								buf[i] = 0
								i++
							} else {
								buf[i] = 1
								i++
								{
									length := len((*ke))
									{
										uv := uint64(length)
										if length < 0 {
											uv = ^(uv << 1)
										} else {
											uv = uv << 1
										}
										{
											for uv >= 0x80 {
												buf[i] = byte(uv) | 0x80
												uv >>= 7
												i++
											}
											buf[i] = byte(uv)
											i++
										}
									}
									for _, el := range *ke {
										{
											si := el.Marshal(buf[i:])
											i += si
										}
									}
								}
							}
							{
								length := len(vl)
								{
									uv := uint64(length)
									if length < 0 {
										uv = ^(uv << 1)
									} else {
										uv = uv << 1
									}
									{
										for uv >= 0x80 {
											buf[i] = byte(uv) | 0x80
											uv >>= 7
											i++
										}
										buf[i] = byte(uv)
										i++
									}
								}
								for ke, vl := range vl {
									{
										si := ke.Marshal(buf[i:])
										i += si
									}
									{
										length := len(vl)
										{
											uv := uint64(length)
											if length < 0 {
												uv = ^(uv << 1)
											} else {
												uv = uv << 1
											}
											{
												for uv >= 0x80 {
													buf[i] = byte(uv) | 0x80
													uv >>= 7
													i++
												}
												buf[i] = byte(uv)
												i++
											}
										}
										for _, el := range vl {
											{
												uv := uint64(el)
												if el < 0 {
													uv = ^(uv << 1)
												} else {
													uv = uv << 1
												}
												{
													for uv >= 0x80 {
														buf[i] = byte(uv) | 0x80
														uv >>= 7
														i++
													}
													buf[i] = byte(uv)
													i++
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return i
}

// Unmarshal parses the MUS-encoded buf, and sets the result to *v.
func (v *TrickySliceAlias) Unmarshal(buf []byte) (int, error) {
	i := 0
	var err error
	{
		var length int
		{
			var uv uint64
			{
				if i > len(buf)-1 {
					return i, muserrs.ErrSmallBuf
				}
				shift := 0
				done := false
				for l, b := range buf[i:] {
					if l == 9 && b > 1 {
						return i, muserrs.ErrOverflow
					}
					if b < 0x80 {
						uv = uv | uint64(b)<<shift
						done = true
						i += l + 1
						break
					}
					uv = uv | uint64(b&0x7F)<<shift
					shift += 7
				}
				if !done {
					return i, muserrs.ErrSmallBuf
				}
			}
			if uv&1 == 1 {
				uv = ^(uv >> 1)
			} else {
				uv = uv >> 1
			}
			length = int(uv)
		}
		if length < 0 {
			return i, muserrs.ErrNegativeLength
		}
		(*v) = make([][2]map[*[]StringAlias]map[SimpleStructType][]int, length)
		for j := 0; j < length; j++ {
			{
				for jj := 0; jj < 2; jj++ {
					{
						var length int
						{
							var uv uint64
							{
								if i > len(buf)-1 {
									return i, muserrs.ErrSmallBuf
								}
								shift := 0
								done := false
								for l, b := range buf[i:] {
									if l == 9 && b > 1 {
										return i, muserrs.ErrOverflow
									}
									if b < 0x80 {
										uv = uv | uint64(b)<<shift
										done = true
										i += l + 1
										break
									}
									uv = uv | uint64(b&0x7F)<<shift
									shift += 7
								}
								if !done {
									return i, muserrs.ErrSmallBuf
								}
							}
							if uv&1 == 1 {
								uv = ^(uv >> 1)
							} else {
								uv = uv >> 1
							}
							length = int(uv)
						}
						if length < 0 {
							return i, muserrs.ErrNegativeLength
						}
						(*v)[j][jj] = make(map[*[]StringAlias]map[SimpleStructType][]int)
						for ; length > 0; length-- {
							kem := new([]StringAlias)
							var vlm map[SimpleStructType][]int
							if buf[i] == 0 {
								i++
								kem = nil
							} else if buf[i] != 1 {
								i++
								return i, muserrs.ErrWrongByte
							} else {
								i++
								{
									var length int
									{
										var uv uint64
										{
											if i > len(buf)-1 {
												return i, muserrs.ErrSmallBuf
											}
											shift := 0
											done := false
											for l, b := range buf[i:] {
												if l == 9 && b > 1 {
													return i, muserrs.ErrOverflow
												}
												if b < 0x80 {
													uv = uv | uint64(b)<<shift
													done = true
													i += l + 1
													break
												}
												uv = uv | uint64(b&0x7F)<<shift
												shift += 7
											}
											if !done {
												return i, muserrs.ErrSmallBuf
											}
										}
										if uv&1 == 1 {
											uv = ^(uv >> 1)
										} else {
											uv = uv >> 1
										}
										length = int(uv)
									}
									if length < 0 {
										return i, muserrs.ErrNegativeLength
									}
									(*kem) = make([]StringAlias, length)
									for j := 0; j < length; j++ {
										{
											var sv StringAlias
											si := 0
											si, err = sv.Unmarshal(buf[i:])
											if err == nil {
												(*kem)[j] = sv
												i += si
											}
										}
										if err != nil {
											err = muserrs.NewSliceError(j, err)
											break
										}
									}
								}
							}
							if err != nil {
								err = muserrs.NewMapKeyError(kem, err)
								break
							}
							{
								var length int
								{
									var uv uint64
									{
										if i > len(buf)-1 {
											return i, muserrs.ErrSmallBuf
										}
										shift := 0
										done := false
										for l, b := range buf[i:] {
											if l == 9 && b > 1 {
												return i, muserrs.ErrOverflow
											}
											if b < 0x80 {
												uv = uv | uint64(b)<<shift
												done = true
												i += l + 1
												break
											}
											uv = uv | uint64(b&0x7F)<<shift
											shift += 7
										}
										if !done {
											return i, muserrs.ErrSmallBuf
										}
									}
									if uv&1 == 1 {
										uv = ^(uv >> 1)
									} else {
										uv = uv >> 1
									}
									length = int(uv)
								}
								if length < 0 {
									return i, muserrs.ErrNegativeLength
								}
								vlm = make(map[SimpleStructType][]int)
								for ; length > 0; length-- {
									var kemm SimpleStructType
									var vlmm []int
									{
										var sv SimpleStructType
										si := 0
										si, err = sv.Unmarshal(buf[i:])
										if err == nil {
											kemm = sv
											i += si
										}
									}
									if err != nil {
										err = muserrs.NewMapKeyError(kemm, err)
										break
									}
									{
										var length int
										{
											var uv uint64
											{
												if i > len(buf)-1 {
													return i, muserrs.ErrSmallBuf
												}
												shift := 0
												done := false
												for l, b := range buf[i:] {
													if l == 9 && b > 1 {
														return i, muserrs.ErrOverflow
													}
													if b < 0x80 {
														uv = uv | uint64(b)<<shift
														done = true
														i += l + 1
														break
													}
													uv = uv | uint64(b&0x7F)<<shift
													shift += 7
												}
												if !done {
													return i, muserrs.ErrSmallBuf
												}
											}
											if uv&1 == 1 {
												uv = ^(uv >> 1)
											} else {
												uv = uv >> 1
											}
											length = int(uv)
										}
										if length < 0 {
											return i, muserrs.ErrNegativeLength
										}
										vlmm = make([]int, length)
										for j := 0; j < length; j++ {
											{
												var uv uint64
												{
													if i > len(buf)-1 {
														return i, muserrs.ErrSmallBuf
													}
													shift := 0
													done := false
													for l, b := range buf[i:] {
														if l == 9 && b > 1 {
															return i, muserrs.ErrOverflow
														}
														if b < 0x80 {
															uv = uv | uint64(b)<<shift
															done = true
															i += l + 1
															break
														}
														uv = uv | uint64(b&0x7F)<<shift
														shift += 7
													}
													if !done {
														return i, muserrs.ErrSmallBuf
													}
												}
												if uv&1 == 1 {
													uv = ^(uv >> 1)
												} else {
													uv = uv >> 1
												}
												vlmm[j] = int(uv)
											}
											if err != nil {
												err = muserrs.NewSliceError(j, err)
												break
											}
										}
									}
									if err != nil {
										err = muserrs.NewMapValueError(kemm, vlmm, err)
										break
									}
									(vlm)[kemm] = vlmm
								}
							}
							if err != nil {
								err = muserrs.NewMapValueError(kem, vlm, err)
								break
							}
							((*v)[j][jj])[kem] = vlm
						}
					}
					if err != nil {
						err = muserrs.NewArrayError(jj, err)
						break
					}
				}
			}
			if err != nil {
				err = muserrs.NewSliceError(j, err)
				break
			}
		}
	}
	return i, err
}

// Size returns the size of the MUS-encoded v.
func (v TrickySliceAlias) Size() int {
	size := 0
	{
		length := len(v)
		{
			uv := uint64(length<<1) ^ uint64(length>>63)
			{
				for uv >= 0x80 {
					uv >>= 7
					size++
				}
				size++
			}
		}
		for _, el := range v {
			{
				for _, item := range el {
					{
						length := len(item)
						{
							uv := uint64(length<<1) ^ uint64(length>>63)
							{
								for uv >= 0x80 {
									uv >>= 7
									size++
								}
								size++
							}
						}
						for ke, vl := range item {
							size++
							if ke != nil {
								{
									length := len((*ke))
									{
										uv := uint64(length<<1) ^ uint64(length>>63)
										{
											for uv >= 0x80 {
												uv >>= 7
												size++
											}
											size++
										}
									}
									for _, el := range *ke {
										{
											ss := el.Size()
											size += ss
										}
									}
								}
							}
							{
								length := len(vl)
								{
									uv := uint64(length<<1) ^ uint64(length>>63)
									{
										for uv >= 0x80 {
											uv >>= 7
											size++
										}
										size++
									}
								}
								for ke, vl := range vl {
									{
										ss := ke.Size()
										size += ss
									}
									{
										length := len(vl)
										{
											uv := uint64(length<<1) ^ uint64(length>>63)
											{
												for uv >= 0x80 {
													uv >>= 7
													size++
												}
												size++
											}
										}
										for _, el := range vl {
											{
												uv := uint64(el<<1) ^ uint64(el>>63)
												{
													for uv >= 0x80 {
														uv >>= 7
														size++
													}
													size++
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return size
}
