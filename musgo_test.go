package musgo

import (
	"errors"
	"fmt"
	"reflect"
	"testing"

	"github.com/ymz-ncnk/musgen/v2"
	musgen_mock "github.com/ymz-ncnk/musgen/v2/testdata/mock"
	"github.com/ymz-ncnk/musgo/parser"
	musgo_mock "github.com/ymz-ncnk/musgo/testdata/mock"
)

// MusGo module tests code generated by the github.com/ymz-ncnk/musgen.
// Those tests are in 'musgen_..._test.go' files. If you want to test unsafe
// code, you should generate it first, see details in the testdata/gen/mus.go
// file.

// To get test coverage of the generated code:
// $ go test -coverpkg=./testdata/musgen -coverprofile=./testdata/musgen/coverage.out
// $ go tool cover -html=./testdata/musgen/coverage.out

func TestMusGo(t *testing.T) {
	makeMocks := func(wantTDesc musgen.TypeDesc, wantLang musgen.Lang,
		wantData []byte,
		wantPath string,
	) (musgen_mock.MusGen, musgo_mock.Persistor) {
		musGen := func() musgen_mock.MusGen {
			return musgen_mock.NewMusGen().RegisterGenerate(
				func(tDesc musgen.TypeDesc, lang musgen.Lang) (
					data []byte, err error) {
					if !reflect.DeepEqual(tDesc, wantTDesc) {
						err = fmt.Errorf("unexpected TypeDesc, want '%v' actual '%v'",
							wantTDesc, tDesc)
						return
					}
					if lang != wantLang {
						err = fmt.Errorf("unexpected Lang, want '%v' actual '%v'", wantLang,
							lang)
						return
					}
					data = wantData
					return
				})
		}()
		persistor := func() musgo_mock.Persistor {
			return musgo_mock.NewPersistor().RegisterPersist(
				func(tDesc musgen.TypeDesc, data []byte, path string) (err error) {
					if !reflect.DeepEqual(tDesc, wantTDesc) {
						err = fmt.Errorf("unexpected TypeDesc, want '%v' actual '%v'",
							wantTDesc, tDesc)
						return
					}
					if !reflect.DeepEqual(data, wantData) {
						err = fmt.Errorf("unexpected Data, want '%v' actual '%v'",
							wantData, data)
						return
					}
					if path != wantPath {
						err = fmt.Errorf("unexpected Path, want '%v' actual '%v'",
							wantPath, path)
						return
					}
					return
				})
		}()
		return musGen, persistor
	}

	t.Run("Generate", func(t *testing.T) {
		// TODO Generate struct.
		type Struct struct {
			Field uint
		}
		var (
			tp             = reflect.TypeOf((*Struct)(nil)).Elem()
			unsafe    bool = true
			wantTDesc      = musgen.TypeDesc{
				Package: "musgo",
				Name:    "Struct",
				Unsafe:  unsafe,
				Suffix:  "MUS",
				Fields: []musgen.FieldDesc{
					{
						Name: "Field",
						Type: "uint",
					},
				},
			}
			wantLang          = musgen.GoLang
			wantData          = []byte{10}
			musGen, persistor = makeMocks(wantTDesc, wantLang, wantData, DefConf.Path)
		)
		musGo, err := NewWith(musGen, persistor)
		if err != nil {
			t.Fatal(err)
		}
		err = musGo.Generate(tp, unsafe)
		if err != nil {
			t.Fatal(err)
		}
	})

	t.Run("GenerateAs", func(t *testing.T) {
		type UintArrayAlias [3]uint
		var (
			tp   = reflect.TypeOf((*UintArrayAlias)(nil)).Elem()
			conf = Conf{
				Unsafe: true,
				Suffix: "Custom",
				Path:   "/a/b/c",
			}
			wantTDesc = musgen.TypeDesc{
				Package: "musgo",
				Name:    "UintArrayAlias",
				Unsafe:  conf.Unsafe,
				Suffix:  conf.Suffix,
				Fields: []musgen.FieldDesc{
					{
						Type:  "[3]uint",
						Alias: "UintArrayAlias",
					},
				},
			}
			wantLang          = musgen.GoLang
			wantData          = []byte{1, 1, 1}
			musGen, persistor = makeMocks(wantTDesc, wantLang, wantData, conf.Path)
		)
		musGo, err := NewWith(musGen, persistor)
		if err != nil {
			t.Fatal(err)
		}
		err = musGo.GenerateAs(tp, conf)
		if err != nil {
			t.Fatal(err)
		}
	})

	t.Run("GenerateAliasAs", func(t *testing.T) {
		type UintUintMapAlias map[uint]uint
		var (
			tp   = reflect.TypeOf((*UintUintMapAlias)(nil)).Elem()
			conf = AliasConf{
				Conf: Conf{
					Unsafe: true,
					Suffix: "Custom",
					Path:   "/a/b/c",
				},
				Validator:     "validator",
				Encoding:      "encoding",
				MaxLength:     10,
				ElemValidator: "elemValidator",
				ElemEncoding:  "elemEncoding",
				KeyValidator:  "keyValidator",
				KeyEncoding:   "keyEncoding",
			}
			wantTDesc = musgen.TypeDesc{
				Package: "musgo",
				Name:    "UintUintMapAlias",
				Unsafe:  conf.Unsafe,
				Suffix:  conf.Suffix,
				Fields: []musgen.FieldDesc{
					{
						Type:          "map-0[uint]-0uint",
						Alias:         "UintUintMapAlias",
						Validator:     conf.Validator,
						Encoding:      conf.Encoding,
						MaxLength:     conf.MaxLength,
						ElemValidator: conf.ElemValidator,
						ElemEncoding:  conf.ElemEncoding,
						KeyValidator:  conf.KeyValidator,
						KeyEncoding:   conf.KeyEncoding,
					},
				},
			}
			wantLang          = musgen.GoLang
			wantData          = []byte{1, 10, 5}
			musGen, persistor = makeMocks(wantTDesc, wantLang, wantData, conf.Path)
		)
		musGo, err := NewWith(musGen, persistor)
		if err != nil {
			t.Fatal(err)
		}
		err = musGo.GenerateAliasAs(tp, conf)
		if err != nil {
			t.Fatal(err)
		}
	})

	t.Run("Generate for alias to pointer", func(t *testing.T) {
		type IntPtrAlias *int
		tp := reflect.TypeOf((*IntPtrAlias)(nil)).Elem()
		musGo, err := New()
		if err != nil {
			t.Fatal(err)
		}
		err = musGo.Generate(tp, false)
		if err != parser.ErrUnsupportedType {
			t.Fatalf("unexpected error, want '%v' actual '%v'",
				parser.ErrUnsupportedType, err)
		}
	})

	t.Run("GenerateAliasAs for unsupported type", func(t *testing.T) {
		// type Struct struct{}
		tp := reflect.TypeOf((*int)(nil)).Elem()
		musGo, err := New()
		if err != nil {
			t.Fatal(err)
		}
		err = musGo.GenerateAliasAs(tp, AliasConf{})
		if err != parser.ErrUnsupportedType {
			t.Fatalf("unexpected error, want '%v' actual '%v'",
				parser.ErrUnsupportedType, err)
		}
	})

	t.Run("GenerateAliasAs for not alias type", func(t *testing.T) {
		type Struct struct{}
		tp := reflect.TypeOf((*Struct)(nil)).Elem()
		musGo, err := New()
		if err != nil {
			t.Fatal(err)
		}
		err = musGo.GenerateAliasAs(tp, AliasConf{})
		if err != ErrNotAlias {
			t.Fatalf("unexpected error, want '%v' actual '%v'",
				parser.ErrUnsupportedType, err)
		}
	})

	t.Run("MusGen failed", func(t *testing.T) {
		type IntAlias int
		var (
			tp      = reflect.TypeOf((*IntAlias)(nil)).Elem()
			wantErr = errors.New("musgen failed")
			musGen  = func() musgen_mock.MusGen {
				return musgen_mock.NewMusGen().RegisterGenerate(
					func(td musgen.TypeDesc, lang musgen.Lang) ([]byte, error) {
						return nil, wantErr
					})
			}()
		)
		musGo, err := NewWith(musGen, nil)
		if err != nil {
			t.Fatal(err)
		}
		err = musGo.Generate(tp, false)
		if err != wantErr {
			t.Fatalf("unexpected error, want '%v' actual '%v'",
				parser.ErrUnsupportedType, err)
		}
	})

}
